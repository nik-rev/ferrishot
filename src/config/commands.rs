//! This module contains macros that define the different `Command`s that are available.
//!
//! # Adding new commands
//!
//! - Invoke the `declare_commands!` macro from any module to generate commands which
//!   will affect the `&mut App`.
//! - Add the module to the `declare_global_commands!` macro invocation below
//! - Implement the [`crate::command::Handler`] trait for the `Command` generated by `declare_commands!`.

use ui::popup::keybindings_cheatsheet;

use crate::ui;

use super::key::{KeyMods, KeySequence};

/// Handles commands which mutate state of the application.
///
/// A `Command` is a subset of a `Message` which can be bound to a keybinding, and
/// can therefore receive a `count`.
pub trait CommandHandler {
    /// Handle the invoked command, mutating the `App`.
    ///
    /// Some commands will behave differently depending on the value of `count`.
    /// `count` represents a number that the user has typed.
    ///
    /// If the `j` key is bound to move down by 1px, typing `200j` will execute
    /// whatever `j` is bound to 200 times, so move down by 200px.
    fn handle(self, app: &mut crate::App, count: u32) -> iced::Task<crate::Message>;
}

/// Create keybindings, specifying the arguments it receives as named fields.
/// Each keybind is declared like this:
///
/// ```text
/// Keybind {
///     a: u32
///     b: bool
///     c: f32
///     d: String
/// }
/// ```
///
/// The above creates a new keybind that will take 4 arguments in order, of the respective types.
/// It can be used in the `config.kdl` file like so:
///
/// ```kdl
/// keys {
///   keybind 10 #false 0.8 hello key=g mods=ctrl
/// }
/// ```
///
/// Which generates a structure like so, when parsed:
///
/// ```no_compile
/// Key::Keybind(10, false, 0.8, "hello", KeySequence("g", None), KeyMods::CTRL)
/// ```
#[macro_export]
macro_rules! declare_commands {
    (
        $(#[$Command_Attr:meta])*
        enum Command {
            $(
                $(#[$Keymappable_Command_Attr:meta])*
                $Keymappable_Command:ident $({$(
                    $(#[$Command_Argument_Attr:meta])*
                    $Command_Argument:ident: $Command_Argument_Ty:ty $(= $Command_Argument_Default:expr)?,
                )+})?
            ),* $(,)?
        }
    ) => {
        $(
            $(#[$Keymappable_Command_Attr])*
            #[derive(ferrishot_knus::Decode, Debug, Clone)]
            pub struct $Keymappable_Command {
                $($(
                    $(#[$Command_Argument_Attr])*
                    $(#[ferrishot_knus(default = $Command_Argument_Default)])?
                    #[ferrishot_knus(argument)]
                    $Command_Argument: $Command_Argument_Ty,
                )+)?
                #[ferrishot_knus(property(name = "key"), str)]
                keys: $crate::config::key::KeySequence,
                #[ferrishot_knus(default, property(name = "mod"), str)]
                mods: $crate::config::key::KeyMods,
            }
        )*

        /// A list of keybindings which exist in the app
        #[derive(ferrishot_knus::Decode, Debug, Clone)]
        pub enum KeymappableCommand {
            $(
                $Keymappable_Command($Keymappable_Command),
            )*
        }

        /// An action in the app
        #[allow(clippy::derive_partial_eq_without_eq, reason = "f32 cannot derive `Eq`")]
        #[derive(Debug, Clone, PartialEq, Copy)]
        $(#[$Command_Attr])*
        pub enum Command {
            $(
                $(#[$Keymappable_Command_Attr])*
                $Keymappable_Command $(
                    {
                        $(
                            $Command_Argument: $Command_Argument_Ty,
                        )*
                    }
                )?,
            )*
        }

        impl KeymappableCommand {
            pub fn action(self) -> (($crate::config::key::KeySequence, $crate::config::key::KeyMods), Command) {
                match self {
                    $(
                        Self::$Keymappable_Command($Keymappable_Command {
                            $(
                                $($Command_Argument,)*
                            )?
                            keys,
                            mods
                        }) => {
                            (
                                (keys, mods),
                                Command::$Keymappable_Command$({
                                    $($Command_Argument),*
                                })?
                            )
                        },
                    )*
                }
            }
        }
    }
}

/// Declare commands for the entire app
///
/// The commands compose commands from everywhere across the app, collected into a single place.
macro_rules! declare_global_commands {
    (
        $(#[$CommandAttr:meta])*
        enum $CommandIdent:ident,

        $(#[$EnumAttr:meta])*
        enum $EnumIdent:ident {
            $(
                $(#[doc = $VariantDoc:literal])*
                $EnumVariant:ident($($InnerCommand:ident)::+)
            ),* $(,)?
        }
    ) => {
        $(#[$CommandAttr])*
        pub enum $CommandIdent {
            $(
                $(#[doc = $VariantDoc])*
                $EnumVariant($($InnerCommand)::+::Command),
            )*
        }

        impl $crate::command::Handler for $CommandIdent {
            fn handle(self, app: &mut $crate::App, count: u32) -> iced::Task<$crate::Message> {
                match self {
                    $(
                        Self::$EnumVariant(cmd) => cmd.handle(app, count),
                    )*
                }
            }
        }

        $(#[$EnumAttr])*
        pub enum $EnumIdent {
            $(
                $(#[doc = $VariantDoc])*
                #[ferrishot_knus(transparent)]
                $EnumVariant($($InnerCommand)::+::KeymappableCommand),
            )*
        }

        impl $EnumIdent {
            /// Key sequence required for this command
            pub fn action(self) -> ((KeySequence, KeyMods), Command) {
                match self {
                    $(
                        Self::$EnumVariant(cmd) => {
                            let (keys, cmd) = cmd.action();
                            (keys, $CommandIdent::$EnumVariant(cmd))
                        },
                    )*
                }
            }
        }
    };
}

declare_global_commands! {
    /// The `Command` is triggered by a series of key presses.
    ///
    /// We store a map from key press to the `Command` on the `App`.
    ///
    /// When the `Command` is obtained, we send a `Message::Command` which contains
    /// payload representing the `Command` that we invoked, as well as the curretn `count`
    /// which lets the user input a number before running a command, which will execute it
    /// that many times. For instance, `200j` executes whatever is bound to `j` 200 times.
    #[derive(Debug, Clone)]
    enum Command,

    /// This is the "raw" command, we get a `Vec` of it when we read the KDL config file.
    ///
    /// ```kdl
    /// keys {
    ///   // contains all of the possible `KeymappableCommand` variants
    /// }
    /// ```
    ///
    /// A `Vec<KeymappableCommand>` gets collected into a `Map<Keys to trigger the Command, Command>`.
    /// Which gets stored on the `App`.
    #[derive(Debug, Clone, ferrishot_knus::Decode)]
    enum KeymappableCommand {
        /// Image Upload
        ImageUpload(crate::image::action),
        /// App
        App(ui::app),
        /// Debug overlay
        DebugOverlay(ui::debug_overlay),
        /// Keybindings Cheatsheet
        KeybindingsCheatsheet(keybindings_cheatsheet),
        /// Letters
        Letters(ui::popup::letters),
        /// Selection
        Selection(ui::selection),
    }
}
